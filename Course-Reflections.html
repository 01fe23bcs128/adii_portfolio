<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Course Reflections | DAA | Dracula Themed Portfolio</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <nav>
            <ul class="navbar">
                <li><a href="home.html">Home</a></li>
                <li><a href="business_cases.html">Business Cases</a></li>
                <li><a href="course_reflections.html">Course Reflections</a></li>
                <li><a href="#contact">Contact</a></li>
            </ul>
        </nav>
    </header>

    <main>
        <section id="course-reflections" class="header-box">
            <h1>Design and Analysis of Algorithms (DAA) - Course Reflections</h1>
            
            <h2>1. What are the kinds of problems we see in nature?</h2>
            <p>Nature provides numerous examples of problem-solving approaches:</p>
            <ul>
                <li><strong>Iteration:</strong> Tides rise and fall in a regular, repeated pattern.</li>
                <li><strong>Recursion:</strong> A cauliflower looks identical at every level, from stem to tip.</li>
                <li><strong>Backtracking:</strong> Solving a maze by retracing steps when hitting a dead end.</li>
            </ul>
            <p>These natural patterns inspire solutions to similar problems in algorithm design.</p>

            <h2>2. What is space and time efficiency? Why are they important?</h2>
            <p><strong>Time efficiency:</strong> Measures how fast an algorithm performs.</p>
            <p><strong>Space efficiency:</strong> Measures how much additional memory it requires.</p>
            <p>If an algorithm is slow or consumes excessive memory, it becomes impractical for large-scale problems.</p>

            <h3>Types of Growth in Algorithms:</h3>
            <ul>
                <li><strong>Constant time (O(1)):</strong> Performance remains the same regardless of input size.</li>
                <li><strong>Logarithmic time (O(log n)):</strong> Slows slightly as input grows.</li>
                <li><strong>Linear time (O(n)):</strong> Performance slows proportionally with input size.</li>
                <li><strong>Linearithmic time (O(n log n)):</strong> Slower than linear, but manageable.</li>
                <li><strong>Quadratic time (O(n²)):</strong> Becomes significantly slower with larger inputs.</li>
                <li><strong>Cubic time (O(n³)):</strong> Even slower than quadratic.</li>
                <li><strong>Exponential (O(2ⁿ)) and Factorial (O(n!)):</strong> Infeasible for large inputs.</li>
            </ul>

            <h2>3. What are the takeaways from different design principles?</h2>
            <p>Effective problem-solving relies on various design principles:</p>
            <ul>
                <li><strong>Divide and Conquer:</strong> Break a problem into smaller parts, solve them individually, and combine results.</li>
                <li><strong>Dynamic Programming:</strong> Store solutions to subproblems to avoid redundant calculations.</li>
                <li><strong>Greedy Algorithms:</strong> Choose the optimal solution at each step.</li>
                <li><strong>Backtracking:</strong> Explore all possibilities and revert incorrect decisions.</li>
            </ul>
            <p>These principles improve algorithm performance and simplify complex problems.</p>

            <h2>4. How do tree data structures solve problems?</h2>
            <p>Trees provide an organized way to store hierarchical data:</p>
            <ul>
                <li><strong>Binary Search Tree (BST):</strong> Efficient for searching sorted data but may become unbalanced.</li>
                <li><strong>AVL Tree:</strong> A self-balancing BST for optimal performance.</li>
                <li><strong>2-3 Tree:</strong> Handles dynamic data effectively.</li>
                <li><strong>Red-Black Tree:</strong> A balanced tree with fewer rebalancing operations.</li>
                <li><strong>Heap:</strong> Quickly finds the largest or smallest value.</li>
                <li><strong>Trie:</strong> Ideal for searching words or prefixes.</li>
            </ul>

            <h2>5. Why do we need array query algorithms?</h2>
            <p>Array query algorithms enhance efficiency in answering range-based questions (e.g., finding the sum or maximum).</p>
            <p><strong>Examples:</strong></p>
            <ul>
                <li><strong>Prefix Sums:</strong> Quickly calculate sums over any range.</li>
                <li><strong>Segment Trees and Fenwick Trees:</strong> Enable fast updates and queries.</li>
            </ul>
            <p>Applications include gaming, financial systems, and databases.</p>

            <h2>6. What is the difference between trees and graphs?</h2>
            <h3>Trees:</h3>
            <ul>
                <li><strong>Structure:</strong> A strict hierarchy with no loops (e.g., family trees).</li>
                <li><strong>Traversals:</strong> Preorder, Inorder, and Postorder for hierarchical analysis.</li>
                <li><strong>Applications:</strong> File organization, decision-making systems.</li>
            </ul>
            <h3>Graphs:</h3>
            <ul>
                <li><strong>Structure:</strong> A collection of nodes and edges, allowing loops (e.g., road maps).</li>
                <li><strong>Traversals:</strong> Depth-First Search (DFS) and Breadth-First Search (BFS) for exploring networks.</li>
                <li><strong>Applications:</strong> Social networks, routing, and navigation systems.</li>
            </ul>

            <h2>7. What about sorting and searching algorithms?</h2>
            <h3>Sorting Algorithms:</h3>
            <ul>
                <li><strong>Simple Algorithms:</strong> Bubble Sort works well for small datasets.</li>
                <li><strong>Efficient Algorithms:</strong> Quick Sort and Merge Sort are suitable for large datasets.</li>
            </ul>
            <h3>Searching Algorithms:</h3>
            <ul>
                <li><strong>Linear Search:</strong> Scans each element, slower but works with unsorted data.</li>
                <li><strong>Binary Search:</strong> Operates on sorted data for faster performance.</li>
            </ul>
            <h3>Real-life Applications:</h3>
            <ul>
                <li>Sorting algorithms rank search results or organize data.</li>
                <li>Searching algorithms locate contacts or find optimal paths in maps.</li>
            </ul>
        </section>
    </main>

    <footer>
        <p>© 2024 Aditi Choudhary. </p>
    </footer>
</body>
</html>
